# Rayquaza Web App

This project is a Flutter web application with a Dart backend, designed to demonstrate best practices in software architecture, including MVVM, SOLID principles, and Object-Oriented Programming (OOP).

## Architecture Overview

The project is structured into two main parts:

1.  **Frontend (Flutter):** Located in the root directory, this is a Flutter application responsible for the user interface and interaction. It follows the **MVVM (Model-View-ViewModel)** architectural pattern.
2.  **Backend (Dart - Vaden Framework):** Located in the `dart_Vaden/` directory, this is a Dart server application built with the Vaden framework, responsible for handling business logic, data storage, and API endpoints.

## MVVM (Model-View-ViewModel) in Flutter

The Flutter frontend adheres to the MVVM pattern to ensure a clear separation of concerns:

*   **Model:** Represents the data and business logic. This includes entities, DTOs (Data Transfer Objects), and services that interact with the backend or local storage. (e.g., `lib/entities`, `lib/dtos`, `lib/services`)
*   **View:** The UI layer, responsible for displaying data and capturing user input. Views are typically Flutter widgets. They observe changes in the ViewModel and update themselves accordingly. (e.g., `lib/pages`, `lib/widgets`)
*   **ViewModel:** Acts as an intermediary between the Model and the View. It exposes data streams and commands that the View can bind to. It contains presentation logic and orchestrates interactions with the Model. In this project, `MobX` is used for state management, which aligns well with the ViewModel concept. (e.g., `lib/states`, `lib/atoms`, `lib/reducers`)

## SOLID Principles

The project aims to follow the **SOLID** principles to promote maintainable, scalable, and understandable code:

*   **Single Responsibility Principle (SRP):** Each class or module has one, and only one, reason to change. For example, a service class is responsible only for data operations, and a UI widget is responsible only for rendering.
*   **Open/Closed Principle (OCP):** Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. This is achieved through interfaces, abstract classes, and dependency injection.
*   **Liskov Substitution Principle (LSP):** Subtypes must be substitutable for their base types without altering the correctness of the program. This ensures that inheritance is used correctly.
*   **Interface Segregation Principle (ISP):** Clients should not be forced to depend on interfaces they do not use. This leads to smaller, more focused interfaces.
*   **Dependency Inversion Principle (DIP):** High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. This is crucial for testability and flexibility, often implemented using dependency injection (e.g., `flutter_modular`).

## Object-Oriented Programming (OOP)

OOP principles are applied throughout the project:

*   **Encapsulation:** Bundling data (attributes) and methods (functions) that operate on the data within a single unit (class). Access to internal state is restricted, and interaction happens through well-defined interfaces.
*   **Inheritance:** Allowing new classes (subclasses) to inherit properties and behaviors from existing classes (superclasses), promoting code reuse.
*   **Polymorphism:** The ability of objects of different classes to be treated as objects of a common superclass. This enables writing generic code that can work with different types of objects.
*   **Abstraction:** Hiding complex implementation details and showing only the essential features of an object. This is achieved through abstract classes and interfaces.

## Getting Started

### Prerequisites

*   Flutter SDK installed and configured.
*   Dart SDK installed and configured.
*   A PostgreSQL database instance (for the backend).

### Running the Backend

1.  Navigate to the `dart_Vaden` directory:
    ```bash
    cd dart_Vaden
    ```
2.  Install dependencies:
    ```bash
    dart pub get
    ```
3.  Configure your PostgreSQL database connection in `dart_Vaden/config.yaml` (or similar configuration file).
4.  Run the backend server:
    ```bash
    dart run bin/server.dart
    ```
    *(Note: You might encounter a `SocketException: Connection refused` error if the database is not running or configured correctly. Ensure your PostgreSQL database is accessible.)*

### Running the Frontend

1.  Navigate to the root project directory:
    ```bash
    cd ..
    ```
2.  Install dependencies:
    ```bash
    flutter pub get
    ```
3.  Run the Flutter application:
    ```bash
    flutter run -d linux # or your preferred device (web, android, ios, etc.)
    ```

## Integrating GetX (Example)

GetX has been added as a dependency. Here's a simple example of how you might use it:

### 1. Create a Controller

```dart
// lib/controllers/my_controller.dart
import 'package:get/get.dart';

class MyController extends GetxController {
  var count = 0.obs; // Observable variable

  void increment() {
    count.value++;
  }
}
```

### 2. Use the Controller in a View

```dart
// lib/pages/my_page.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../controllers/my_controller.dart';

class MyPage extends StatelessWidget {
  final MyController myController = Get.put(MyController()); // Instantiate your controller

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX Example')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Obx(() => Text('Count: ${myController.count.value}')), // Observe changes
            ElevatedButton(
              onPressed: () => myController.increment(),
              child: Text('Increment'),
            ),
          ],
        ),
      ),
    );
  }
}
```

### 3. Update `main.dart` (or your routing setup)

If you are using `GetMaterialApp` for routing and dependency injection:

```dart
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'pages/my_page.dart'; // Your new page

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'Rayquaza Web App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyPage(), // Set your new page as home
    );
  }
}
```

Remember to adapt this example to your project's existing routing and state management setup (e.g., `flutter_modular`, `MobX`). You might integrate GetX for specific features or replace existing state management solutions gradually.